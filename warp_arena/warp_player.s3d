#include "warp_bullet.s3d"
#include "warp_status.s3d"
#include "warp_weapons.s3d"

//frame di movimento
#define SWAT_START_WALK 16
#define SWAT_END_WALK   48
//PLayer position spawn
#define myPosX 19
#define myPosY 0
#define myPosZ 4
//distance between player and camera
#define distance  2
#define altitude 1.7

var level_matrix;
//position of the camera
var CamPos;
// Variabili placeholder per la posizione
var i;
var J;
var i_new;
var j_new; 

class player
{
  var myCamera;
  var myMouse;
  var lower_mesh;
  var angle; //initial player direction
  var view; //1=third person, 0=first person
  var fp_cam; //to 0 when the third person camera goes inside a wall
  var upper_mesh;
  var lower_obj;
  var upper_obj;
  var weapon_mesh;
  var weapon_obj;
  var myWeapon;
  var obj;
  var position;
  var pos_l; //position of the object directly to the players left
  var pos_r; //position of the object directly to the players right
  var pos_ol; //position of the object in the front (or in the back) left diagonal
  var pos_or; //position of the object in the front (or in the back) right diagonal
  var direction;
  var step;
  var frame_step;
  var current_frame;
  var run;
  var my_bullet;
  var bullet_array;
  var shot_cnt;
  var has_shot;
  var color;
  var shoot_fx;
  var step_fx;
  var j_up;
  var j_down;
  var j_count;
  var J_finalPos;
  var cam_x;
  var cam_z;
  var cam_inside;
  var campos1;
  var oldposition;
  var oldCamPos;
  var curr_weapon;
  var weapon_mesh0;
  var weapon_mesh1;
    
  init(col);
  draw();
  setposition(pos);
  setrotation(angle);
  update();
  collision_check(fl);
};

function player::init(col)
{
  bullet_array = array(0);
  shot_cnt = 0;
  has_shot = false;
  angle = 0;
  view = 1;
  fp_cam = 1;
  cam_x = 0;
  cam_z = 0;
  cam_inside = 0;
  campos1 = 0;
  color = col;
  j_up = 0;
  j_down = 0;
  j_count = 0;
  myMouse = CVmMouse();
  curr_weapon = 0;
  
  lower_mesh = CVmNewMesh("swat_lower.aam");
  var sf1 = lower_mesh.normalize(1);
  upper_mesh = CVmNewMesh("swat_upper.aam");
  upper_mesh.scale(sf1);
  weapon_mesh0 = CVMNewMesh("rocketl.aam");
  weapon_mesh0.scale(sf1);
  weapon_mesh1 = CVMNewMesh("railgun.aam");
  weapon_mesh1.scale(sf1);
  myWeapon = weapon();
  myWeapon.init();
  lower_obj = CVmObj(lower_mesh);
  upper_obj = CVmObj(upper_mesh);
  weapon_obj = CVmObj(weapon_mesh0);
  
  obj = CVmObj();
  obj.addchild(upper_obj);
  obj.addchild(lower_obj);
  obj.addchild(weapon_obj);
  
  obj.ModulateMaterials(color);
  
  angle = 0;
  // z è avanti
  // x è di lato
  direction = [0,0,1];
  pos_l = [0,0,0];
  pos_r = [0,0,0];
  step = 0.1;
  frame_step = 1.0;
  current_frame = SWAT_START_WALK;
  run = 1;
  
  shoot_fx = CVmVRAWAV("shoot.wav");
  step_fx  = CVmVRAWAV("step.wav");
}

/******************************************************************************************************************
 *                                           |PLAYER MOVEMENT|                                                    *
 *----------------------------------------------------------------------------------------------------------------*
 * The following code is realized in order to let the plaer move in the map. The keyboard is used as main method  *
 * of movement. The involved keys and their meaning are defined as follows:                                       *
 *                                                                                                                *
 *     -> Shift: used as toggle, keep pressed to run;                                                             *
 *     -> A: used to turn the avatar to his left. This key changes only the angle, it does not let him move;      *
 *     -> D: used to turn the avatar to his right. This key changes only the angle, it does not let him move;     *
 *    -> Space Bar: lets the avatar jump. This can be also used to climb on objects that have y coordinate that   *
 *               is less that the maximum height of the jump;                                                     *
 *     -> W: used to make the avatar walk forward;                                                                *
 *     -> S: used to make the avatar walk backwards;                                                              *
 *     -> E: positions the camera in first person view;													                  *
 *     -> F: positions the camera in third person view;                                                           *
 *     -> I: shoots with the currently equipped weapon.                                                           *			
 ******************************************************************************************************************/
function player::update()
{   
  oldposition = position;
  oldCamPos = CamPos;
     
   // Corsa
  if (keypressed(VK_SHIFT))
    run = 2;
  else
    run = 1;
  
	// Turn left
	if (keypressed("A"))
	{
		if (!keypressed(VK_CONTROL))
			angle += 0.02;
	}
	// Turn right  
	else if (keypressed("D"))
		if (!keypressed(VK_CONTROL))
    		angle -= 0.02;
    
  // Direzione del personaggio 
  direction = [sin(angle), 0, cos(angle)];
  
  // Jump
  if (keypressed(VK_SPACE))
  {
    if(j_up == 0 && j_down == 0)
    {
      j_up = 1;
      j_count = 0;
    }
  }
  if(j_up == 1)
  {
    position.y +=  0.1;
    j_count += 0.1;
    if (j_count >= 1.5)
    {
      j_up = 0;
      j_down = 1;
    }
  }
  else if (j_down == 1)
  {
     i = int(position.z);
     j = int(position.x);
     j_finalPos = level_matrix[i][j];
     // Se la posizione finale è più bassa della posizione in cui devo stare
     // allora devo piallare tutto alla posizione finale.
    if (position.y <= j_finalPos  && (j_finalPos - position.y <= 1))
    {
      j_down = 0;
      position.y = j_finalPos;
      j_count = 0;
    }
    else 
    {
      // Devo stare attento che non vada in negativo.
      // I controlli non sono mai troppi, mannaggia la madonna
      position.y -= 0.1;
      oldposition.y -= 0.1;
      if (position.y < 0)
       position.y = j_finalPos;
    }
  }
  // Forward walk
  if (keypressed("W"))
  {  
    i = int(position.z);
    j = int(position.x);
    position += (direction*step*run);
    i_new = int(position.z);
    j_new = int(position.x);
    // Se vado verso una zona più bassa, allora devo scendere
    if (level_matrix[i_new][j_new] < level_matrix[i][j])
      j_down = 1;
      
    CamPos += (direction*step*run);
    current_frame += frame_step;
    if (current_frame > SWAT_END_WALK)
    {
      step_fx.play();
      current_frame = SWAT_START_WALK;
    }
    collision_check(1);
 }

  // Backwards Walk
  else if (keypressed("S"))
  {  
    i = int(position.z);
    j = int(position.x);
    position -= (direction*step*run);
    i_new = int(position.z);
    j_new = int(position.x);
    // Se vado verso una zona più bassa, allora devo scendere
    if (level_matrix[i_new][j_new] < level_matrix[i][j])
    {
      j_down = 1;
    }
    CamPos -= (direction*step*run);
    current_frame -= frame_step;
    if (current_frame < SWAT_START_WALK)
    {
      current_frame = SWAT_END_WALK;
    }

	collision_check(0);
  }
  // E for first person, F to go back to third person
  if (keypressed("E"))
    view = 0;

  if (keypressed("F"))
    view = 1;
      
  setrotation(angle);
  setposition(position);
  CameraGetCurrent().SetPosition(CamPos);
  
  /*
   * Per lo sparo bisogna creare un array di istanze, una per ogni bullet.
   * Per ogni proiettile, bisogna tenerne traccia, mediante l'istanza dell'oggetto che gli compete.
   */
	if (keypressed("I"))
   {
		if (!has_shot) 
		{
			var check = myWeapon.update(curr_weapon);
			if (check == true)
			{
				my_bullet = bullet();
				my_bullet.init(position, direction, level_matrix);
				aadd(bullet_array, my_bullet);
				shoot_fx.play();
				has_shot = true;
			}
		}
	} 
  
	if (keypressed("J"))
	{ 
		obj.RemoveChild(weapon_obj);
		weapon_obj = CVmObj(weapon_mesh0);
		obj.addchild(weapon_obj);
		curr_weapon = 0;
		myWeapon.swap(curr_weapon);

	}
		
	if (keypressed("K"))
	{ 
		obj.RemoveChild(weapon_obj);
		weapon_obj = CVmObj(weapon_mesh1);
		obj.addchild(weapon_obj);
		curr_weapon = 1;
		myWeapon.swap(curr_weapon);
	}

	for(var k = 0; k < len(bullet_array); k++)
		bullet_array[k].update();


  //updates camera focal point
  CameraGetCurrent().SetTarget(position.x+sin(angle)*(distance+3), position.y+(1-view)*2, position.z+cos(angle)*(distance+3));
  
}

function player::draw()
{
	if (view == 1)
		obj.draw(VR_FRAMENUMBER, current_frame);
	else
		obj.draw(VR_FRAMENUMBER, 1);
		
	for(var k = 0; k < len(bullet_array); k++)
	{
		if(bullet_array[k].hit_fg == true)
			adel(bullet_array, k);
		else
			bullet_array[k].draw();
	}
	
}

function player::setposition(pos)
{
  position = pos;
  obj.setposition(position); //sets players position
  pos_l = position;
  pos_r = position;
  pos_ol = position;
  pos_or = position;
}

function player::setrotation(angle)
{
  obj.setrotation(angle*180.0/PI, 0, 1, 0);
  //rotates camera(depending also on the view)
  
  //questo è il calcolo normale, se non ho problemi di visuale in terza persona.
  if(fp_cam == 1)
    CamPos = [position.x+sin(-angle)*distance*view+(1-view)*sin(-angle)*0.5, position.y+altitude-(1-view)*0.5, position.z-distance*cos(angle)*view-(1-view)*cos(angle)*0.5];
  else
  {
    //questo è il calcolo della telecamera normale, basato sulla visuale
    CamPos = [position.x+sin(-angle)*distance*view+(1-view)*sin(-angle)*0.5, position.y+altitude-(1-view)*0.5, position.z-distance*cos(angle)*view-(1-view)*cos(angle)*0.5];
    //questo è il calcolo della terza persona (anche se non la vedo), giusto per controllare se sono uscito dal muro nel caso di
    //telecamera in terza persona che incontra il muro.
    //Se quindi sono uscito, ripristino la telecamera in terza persona.
    CamPos1 = [position.x+sin(-angle)*distance*(1-view)+view*sin(-angle)*0.5, position.y+altitude-view*0.5, position.z-distance*cos(angle)*(1-view)-view*cos(angle)*0.5];
    cam_z = int(CamPos1.z);
    cam_x = int(CamPos1.x);
    
    if (cam_z < 0 )
      cam_z = 0;
    if (cam_x < 0)
      cam_x = 0;

    //a questo punto controllo se la telecamera (dalla quale in verità non sto vedendo), è uscita dal muro. Se tale è il caso allora la ripristino.
    var cam_not_inside = level_matrix[cam_z][cam_x];
    if (cam_not_inside < CamPos1.y){
      fp_cam = 1;
      view = 1;
    }
  }
  //adesso controllo se sono finito dentro il muro 
  cam_z = int(CamPos.z);
  cam_x = int(CamPos.x);
  var cam_inside = level_matrix[cam_z][cam_x];
  
  // Se la telecamera sta andando in una casella la cui altezza supera l'altezza dove è,
  // Allora non devo entrarci e spostarla in prima persona. Viene effettuato il controllo solo se sono in terza persona.
    if ((cam_inside > CamPos.y) && (view == 1)){
    fp_cam = 0;
    view = 0;
  }
}
/******************************************************************************************************************
 *                                        |COLLISION DETECTION|                                                   *
 *----------------------------------------------------------------------------------------------------------------*
 * This function was created in order to implement a more efficient collision detection algorithm in warp arena.  * 
 * Our algorithm does not revolve around the use of the bounding box function that can be found in XVR.			  *
 * Every time a player moves his position, we check different directions: the one in front, the ones on the left  *
 * and on the right, and the diagonal ones (front-left and front-right). If we collide only in front, we do       *
 * nothing and keep the old position. If we collide in another direction, we restore only the corresponding       *
 * component to the one he is not moving in. This was done in order to achieve a sliding effect during gameplay.  *
 ******************************************************************************************************************/
function player::collision_check(fl)
{
	var i_ol;
	var i_or;
	var j_ol;
	var j_or;
	var a = angle + (pi/2);
 	var b = angle + (pi/4);
 	var c = angle - (pi/4);
 	var d = angle + (3*pi/4);
 	var e = angle - (3*pi/4);
 	
  	var dirleft = [sin(a), 0, cos(a)];
  	var diroblique_l = [sin(b), 0, cos(b)];
  	var diroblique_r = [sin(c), 0, cos(c)];
  	var diroblique_bl = [sin(d), 0, cos(d)];
  	var diroblique_br = [sin(e), 0, cos(e)];
	// Collision detection DEVO CONTROLLARE ANCHE LE CASELLE ACCANTO AL PLAYER
    pos_l += (dirleft * step * run);
    pos_r -= (dirleft * step * run);
    
	if (fl == 1)
	{
    pos_ol += (diroblique_l * step * run);
	 pos_or += (diroblique_r * step * run);
	 i = int(position.z + direction.z);
    j = int(position.x + direction.x);
	}
	else
	{
    pos_ol += (diroblique_bl * step * run);
	 pos_or += (diroblique_br * step * run);
	 i = int(position.z - direction.z);
    j = int(position.x - direction.x);
	}
    
    if (i < 0)
      i = 0;
    if (j < 0)
      j = 0;

    var i_l = (floor(pos_l.z + dirleft.z) < 0) ? 0 : floor(pos_l.z + dirleft.z); 
    var j_l = (floor(pos_l.x + dirleft.x) < 0) ? 0 : floor(pos_l.x + dirleft.x); 
    var i_r = (floor(pos_r.z - dirleft.z) < 0) ? 0 : floor(pos_r.z - dirleft.z); 
    var j_r = (floor(pos_r.x - dirleft.x) < 0) ? 0 : floor(pos_r.x - dirleft.x);
    
    if (fl == 1)
    {
    	i_ol = (floor(pos_ol.z + diroblique_l.z) < 0) ? 0 : floor(pos_ol.z + diroblique_l.z); 
    	j_ol = (floor(pos_ol.x + diroblique_l.x) < 0) ? 0 : floor(pos_ol.x + diroblique_l.x); 
    	i_or = (floor(pos_or.z + diroblique_r.z) < 0) ? 0 : floor(pos_or.z + diroblique_r.z); 
    	j_or = (floor(pos_or.x + diroblique_r.x) < 0) ? 0 : floor(pos_or.x + diroblique_r.x);
    }
    else
    {
    	i_ol = (floor(pos_ol.z + diroblique_bl.z) < 0) ? 0 : floor(pos_ol.z + diroblique_bl.z); 
    	j_ol = (floor(pos_ol.x + diroblique_bl.x) < 0) ? 0 : floor(pos_ol.x + diroblique_bl.x); 
    	i_or = (floor(pos_or.z + diroblique_br.z) < 0) ? 0 : floor(pos_or.z + diroblique_br.z); 
   	 	j_or = (floor(pos_or.x + diroblique_br.x) < 0) ? 0 : floor(pos_or.x + diroblique_br.x);
    }
    var i_old = int(oldposition.z); 
    var j_old = int(oldposition.x);
    
    var inside = level_matrix[i][j];
    var inside_l = level_matrix[i_l][j_l];
    var inside_r = level_matrix[i_r][j_r];
    var inside_ol = level_matrix[i_ol][j_ol];
    var inside_or = level_matrix[i_or][j_or];
    /* 
    if ((inside_ol > (j_count+position.y)) && (inside_or > (j_count+position.y)))
    {
      position.x = oldposition.x;
      position.z = oldposition.z;
      CamPos.x = oldCamPos.x;
      CamPos.z = oldCamPos.z;
    }*/
    if ((inside_l > (j_count+position.y)) && (inside_ol > (j_count+position.y)))
    {
      if ( (i_l == i_ol) && (j != j_old))
      {
        position.z = oldposition.z;
        CamPos.z = oldCampos.z;
      }
      else if (j_l == j_ol)
      {
        position.x = oldposition.x;
        CamPos.x = oldCampos.x;
      }
      
    }
    if ((inside_r > (j_count+position.y)) && (inside_or > (j_count+position.y)))
    {
      if ( (i_r == i_or) && (i == i_old))
      {
        position.z = oldposition.z;
        CamPos.z = oldCampos.z;
      }
      else if (j_r == j_or)
      {
        position.x = oldposition.x;
        CamPos.x = oldCampos.x;
      }
    }
    if (inside > (j_count+position.y))
    {
      position.x = oldposition.x;
      position.z = oldposition.z;
      CamPos.x = oldCamPos.x;
      CamPos.z = oldCamPos.z;
    }  
}
