//minimum time to shoot between frames
#include "warp_globals.s3d"
#define min_shot  50

class bullet
{
	var position;
	var direction;
	var speed;
	var mesh;
	var obj;
	var matrix;
	var hit_fg;
	var damage;
	var bull_id;
	var tipo;
	
	init(pos, dir, type, id);
	update();
	draw_bullet();
};

function bullet::init(pos, dir, type, id)
{
	matrix = level_matrix;
	position  = pos + [0, 1, 0];
	bull_id = id;
	tipo = type;

	direction = dir;
	speed = 0.5;
	switch (type)
	{
		case 0 :
			mesh = CVMNewMesh(VRP_SPHERE);
			mesh.Scale(0.02);	
			damage = 1;
			speed = 0.7;
			obj = CVmObj(mesh);
			obj.SetPosition(position);
			mesh.ModulateMaterials(0, 0, 0, 1);
			break;
	
		case 1 :
			mesh = CVMNewMesh(VRP_SPHERE);
			mesh.Scale(0.05);	
			damage = 5;
			speed = 0.5;
			obj = CVmObj(mesh);
			obj.SetPosition(position);
			mesh.ModulateMaterials(0, 0, 0, 1);
			break;
		
		case 2 :
			mesh = CVMNewMesh(VRP_SPHERE);
			mesh.Scale(0.02);	
			damage = 0;
			speed = 0.7;
			obj = CVmObj(mesh);
			obj.SetPosition(position);
			mesh.ModulateMaterials(0, 0, 0.4, 1);
			break;
	
		default :
	}

	hit_fg = False;
}

function bullet::update()
{
	position += direction*speed;
	var i = int(position.z);
  	var j = int(position.x);
   	var hit = matrix[i][j];
   
	if (hit > position.y)
		hit_fg = True;
	else	
		obj.SetPosition(position);

//   foreach(var t in obj_array)
//   {
//   	hit_fg = t.iscollidingBBox(obj);
//   	var g = t.getposition();
//   	trace(hit_fg, g, position);
//   	
//   	
//   	if (hit_fg)
//   	   break;
//   }
//   
//   if (hit_fg == false)
//   	obj.SetPosition(position);
}

function bullet::draw_bullet()
{
	obj.draw();
}